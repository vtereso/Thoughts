The "Less Template, More Tekton" proposal is a reflection of https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md regarding Tekton (referring to the tektoncd/pipeline repo onward). This related Kubernetes document discusses 'Declarative application management in Kubernetes', while Tekton is a "open-source framework for creating continuous integration and delivery (CI/CD) systems"; this is achieved through custom resources and controllers. I see a visible differentiation between these two objectives where Kubernetes aims to "provide IaaS-like container-centric primitives" and Tekton's objective is to enable you to create CI/CD systems (accomplished through custom resources). The common denominator between these two is that Tekton _is_ Kubernetes native, so consequently, work is delegated to Kubernetes; this is manifested in the form of pods.

Although some frameworks can be pluggable and deemed "unopinionated", without making decisions you cannot build abstractions (or anything for that matter). Tekton workloads functionally evaluate to pods, but as I understand it, the empowerment is in the separation of code and configuration inherent to Tekton. Without this, Tekton is no different from any other CI/CD offering because ultimately, these systems are just providing an "automated" way to run some code you already wrote. To achieve this separation, Tekton resources (or the API depending on how you view it) provide opinionated schemas for both configuration resources (PipelineResources), workload skeletons (Tasks/Pipelines), and workloads (TaskRuns/PipelineRuns). Each of these resource classifications play a role that embodies what I believe to be the Tekton philosphy.

Regarding Kubernetes and from an application management lense, it makes sense to use ConfigMaps to store static configurations, which would otherwise complicate the specification of say a Deployment. One other alternative would be to create a custom resource to encapsulate some ad-hoc configuration. Creating such a resource would probably be a poor decision because over time this definition would likely change and in the end it would likely end up very similar to the ConfigMap schema. To this point, one stance might be to eliminate PipelineResources since they only serve as blueprints or "templates" (they do not create, but instead specify some config). In either perspective, with the Tekton mantra of separating code and configuration I believe it is clear that this needs to exist somewhere (in some representation) and it is very much pure configuration (e.g. the above ConfigMap contension). To the pursue the thought that ConfigMap's would be the more native embodiment here, labels would likely be needed to help distinguish the proposed ConfigMap to represent the same structure as current PipelineResources. Yet, anything can be specified in the ConfigMap data field, and in comparison, PipelineResources only care about a specific few fields. If for nothing else than clarity of naming, I believe a specific/rigid schema helps prevent mistakes/confusion. If Tekton utilized ConfigMap's here instead, users might misintepret the intent, other controllers might process these unnecessarily, labels might be accidently omitted leading to more confusion, etc. On positive here is that introducing new PipelineResource types would be easier as the controllers would only have to account for this new label and process accordingly. So, despite potential label issues and assuming controllers could correctly validate the intended structure, I believe this stands as strongest argument out of any to consider being replaced and is _still_ entirely debatable.

In what can be regarded as one of, if not, the core building block of Tekton, Tasks enable users to provide mock a shell for some functionality (separates code and configuration), which enables pluggability for parameters in what has been regarded as "templating", but is actually variable interpolation. Further, steps are executed in an ordered fashion within a task compared to a PodTemplate (a non-instantiated PodSpec), that does not orchestrate these containers in any way. Also, despite the name, PodTemplates do not support "templating" in the sense of variable interpolation or otherwise, but rather encapsulate configuration for things to be instantiated upon later similar to other Tekton concepts. For arguments sake, Tasks can be compared as having a single step and PodTemplates with a single container. In this way, maybe Task steps could utilize a slice of PodSpec compared to the current TaskSpec, but to the same point as ConfigMaps, there are many different fields within a PodTemplate that many people are probably not concerned with and it breaks the same benefit (using Kubernetes concepts) being sought after in multiple ways (e.g. Someone could specify multiple containers in a PodSpec). The only "templating" that Kubernetes allows is variable interpolation within very specific location of certain resource definitions where Tekton allows for it to be done across most of the resource (https://github.com/tektoncd/pipeline/blob/master/pkg/reconciler/v1alpha1/taskrun/resources/apply.go). One instance where this enables users to see reuse is in a task where the image in question needs to refer to a particular tag. The tag can be passed in from a TaskRun (discussed more later), which allows a single Task to encapsulate the same work compared to rewriting it multiple times in simply the instantiated location. This is akin to creating a package that is imported elsewhere. From just this primitive example, PodTemplates or other native Kubernetes concepts don't allow for this sort of thing. It is this sort of functionality inadequacy that has prompted the creation of all sorts of tools and DSLs (as outlined in the motivating doc behind the proposal), each with their own problem domain (for better or worse). Moreso, efforts are underway to adopt the Kubernetes interpolation syntax so this should not seem like a farcry for users who are familiar with the space.

Like Pods, TaskRuns and PipelineRuns are the true actuators of work. These resources aggregate configuration and inject them into the aforemention Tasks. In certain instances, reuse is not a concern and for that reason I believe it does make sense that we should consider embedding Pipelines/PipelineResources into PipelineRuns. Still, as a proponent I could see an argument against it for the same reason that it could mangle/twist understand in the same way that ConfigMaps for PipelineResources could. Should PipelineRuns become the singular resource provided by Tekton, I don't see how code and configuration have been separated in any meaningful way, and in this circumstance, the only leverage/use Tekton is providing is to orchestrate work/containers to execute in some predefined order. To this point, it seems that at the core what you are seeking is a resource that will do this, presumably with PodTemplates as the hypothetical "step". I believe Tekton's current resource architecture is what makes it attractive, not simply because of the DAG overlay it provides to containers.

To the point of TriggerTemplates not being necessary, I believe this coincides with the same idea of allowing for optional embedding. Whether two CRD has been registered or one is simply supports the structure of other internally, I don't believe this could fundamentally confuse people or that it ties to the idea of "less templates". Following Tekton's reuse principle, they should be separated because TriggerBindings override the parameters specified in the TriggerTemplate amongst other things that distinguish the two. It is the TriggerTemplate that is documenting what should be templated, which also utilizes optional variable interpolation from event payloads.

For the reasons outlined above, I personally don't believe it makes sense to get rid of the current variable interpolation in favor or exporting this functionality to other tools. For one, I believe the reuse that Tekton seeks necessitiates variable interpolation. From my perspective, this proposal removes the unique value add (the resource architecture, etc.) that Tekton is providing. The current architecture doesn't seem flawed to me and the functionality already exists. It would be cumbersome to remove variable interpolation and the only potential benefit is allowing people to use other tools that I believe lack the power that Tekton currently has (Kustomize or otherwise). Although heavily biased, I believe that Triggers is what will really further highlight the power of this interpolation by enabling event to pass down this configuration into the workloads that have already been defined. I do believe that PipelineResources "could" be implemented differently and the internal structure of Tasks "could" utilize Kubernetes more, which could warrant discussion.